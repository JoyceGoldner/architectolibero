{"version":3,"sources":["../../es256k-jws-ts/dist/esm5/JWS.js","App.js","serviceWorker.js","index.js","../../es256k-jws-ts/dist/esm5/keyUtils.js","../../lds-ecdsa-secp256k1-2019/dist/esm5/index.js","../../lds-ecdsa-secp256k1-2019/dist/esm5/createVerifyData/index.js"],"names":["Buffer","tslib__WEBPACK_IMPORTED_MODULE_0__","__webpack_require__","base64url__WEBPACK_IMPORTED_MODULE_1__","base64url__WEBPACK_IMPORTED_MODULE_1___default","n","bitcoin_ts__WEBPACK_IMPORTED_MODULE_2__","crypto__WEBPACK_IMPORTED_MODULE_3__","crypto__WEBPACK_IMPORTED_MODULE_3___default","_keyUtils__WEBPACK_IMPORTED_MODULE_4__","JWSVerificationFailed","_super","message","_this","call","this","name","Error","__webpack_exports__","decode","jws","options","complete","_a","split","encodedHeader","encodedPayload","encodedSignature","header","JSON","parse","a","payload","signature","sign","privateKeyJWK","alg","undefined","privateKeyUInt8Array","secp256k1","toBeSigned","digest","messageHashUInt8Array","signatureUInt8Array","signatureHex","label","Object","sent","encode","stringify","from","createHash","update","toString","signMessageHashCompact","signDetached","b64","crit","toBeSignedBuffer","concat","buffer","byteOffset","length","verify","publicKeyJWK","publicKeyUInt8Array","_b","toBuffer","verifySignatureCompact","verifyDetached","privateJWK","crv","d","kid","kty","x","y","publicJWK","signatureOptions","challenge","created","domain","proofPurpose","verificationMethod","doc","@context","action","schema","App","state","JWS","ES256K","hello","verified","setState","EcsdaSecp256k1Signature2019","ldSig","lsSigVerified","react_default","createElement","className","React","Component","Boolean","window","location","hostname","match","ReactDOM","render","src_App","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","privateKeyUInt8ArrayFromJWK","publicKeyUInt8ArrayFromJWK","_trust_keyto__WEBPACK_IMPORTED_MODULE_1__","_trust_keyto__WEBPACK_IMPORTED_MODULE_1___default","bitcoin_ts__WEBPACK_IMPORTED_MODULE_4__","privateKeyHexFromJWK","jwk","publicKeyHexFromJWK","uncompressedPublicKey","compressed","compressPublicKey","privateKeyHex","publicKeyHex","_createVerifyData__WEBPACK_IMPORTED_MODULE_1__","_transmute_es256k_jws_ts__WEBPACK_IMPORTED_MODULE_2__","privateKeyJwk","framed","verifyDataHexString","verifyDataBuffer","proof","publicKeyJwk","crypto__WEBPACK_IMPORTED_MODULE_1__","crypto__WEBPACK_IMPORTED_MODULE_1___default","jsonld__WEBPACK_IMPORTED_MODULE_2__","jsonld__WEBPACK_IMPORTED_MODULE_2___default","canonize","data","sha256","h","cannonizeSignatureOptions","_signatureOptions","signatureValue","proofValue","cannonizeDocument","_doc","expanded","cannonizedSignatureOptions","hashOfCannonizedSignatureOptions","cannonizedDocument","hashOfCannonizedDocument","creator","Date","toISOString","type","expand","compact","skipExpansion"],"mappings":"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","file":"static/js/main.2f601470.chunk.js","sourcesContent":["var _this = this;\n\nimport * as tslib_1 from \"tslib\";\nimport base64url from 'base64url';\nimport { binToHex, hexToBin, instantiateSecp256k1 } from 'bitcoin-ts';\nimport crypto from 'crypto';\nimport { privateKeyUInt8ArrayFromJWK, publicKeyUInt8ArrayFromJWK } from './keyUtils';\n\nvar JWSVerificationFailed =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(JWSVerificationFailed, _super);\n\n  function JWSVerificationFailed(message) {\n    var _this = _super.call(this, message) || this;\n\n    _this.name = 'JWSVerificationFailed';\n    return _this;\n  }\n\n  return JWSVerificationFailed;\n}(Error);\n\nexport var signDetached = function signDetached( // in the case of EcdsaSecp256k1Signature2019 this is the result of createVerifyData\npayload, privateKeyJWK, header) {\n  if (header === void 0) {\n    header = {\n      alg: 'ES256K',\n      b64: false,\n      crit: ['b64']\n    };\n  }\n\n  return tslib_1.__awaiter(_this, void 0, void 0, function () {\n    var privateKeyUInt8Array, secp256k1, encodedHeader, toBeSignedBuffer, message, digest, messageHashUInt8Array, signatureUInt8Array, signatureHex, encodedSignature;\n    return tslib_1.__generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , privateKeyUInt8ArrayFromJWK(privateKeyJWK)];\n\n        case 1:\n          privateKeyUInt8Array = _a.sent();\n          return [4\n          /*yield*/\n          , instantiateSecp256k1()];\n\n        case 2:\n          secp256k1 = _a.sent();\n          encodedHeader = base64url.encode(JSON.stringify(header));\n          toBeSignedBuffer = Buffer.concat([Buffer.from(encodedHeader + '.', 'utf8'), Buffer.from(payload.buffer, payload.byteOffset, payload.length)]);\n          message = Buffer.from(toBeSignedBuffer);\n          digest = crypto.createHash('sha256').update(message).digest().toString('hex');\n          messageHashUInt8Array = hexToBin(digest);\n          signatureUInt8Array = secp256k1.signMessageHashCompact(privateKeyUInt8Array, messageHashUInt8Array);\n          signatureHex = binToHex(signatureUInt8Array);\n          encodedSignature = base64url.encode(Buffer.from(signatureHex, 'hex'));\n          return [2\n          /*return*/\n          , encodedHeader + \"..\" + encodedSignature];\n      }\n    });\n  });\n};\nexport var verifyDetached = function verifyDetached(jws, payload, publicKeyJWK) {\n  return tslib_1.__awaiter(_this, void 0, void 0, function () {\n    var _a, encodedHeader, encodedSignature, header, publicKeyUInt8Array, secp256k1, toBeSignedBuffer, message, digest, messageHashUInt8Array, signatureUInt8Array, verified;\n\n    return tslib_1.__generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          _a = jws.split('..'), encodedHeader = _a[0], encodedSignature = _a[1];\n          header = JSON.parse(base64url.decode(encodedHeader));\n\n          if (header.alg !== 'ES256K') {\n            throw new Error('JWS is not signed with ES256K.');\n          }\n\n          if (header.b64 !== false || !header.crit || !header.crit.length || header.crit[0] !== 'b64') {\n            throw new Error('JWS is not in rfc7797 format (not detached).');\n          }\n\n          return [4\n          /*yield*/\n          , publicKeyUInt8ArrayFromJWK(publicKeyJWK)];\n\n        case 1:\n          publicKeyUInt8Array = _b.sent();\n          return [4\n          /*yield*/\n          , instantiateSecp256k1()];\n\n        case 2:\n          secp256k1 = _b.sent();\n          toBeSignedBuffer = Buffer.concat([Buffer.from(encodedHeader + '.', 'utf8'), Buffer.from(payload.buffer, payload.byteOffset, payload.length)]);\n          message = Buffer.from(toBeSignedBuffer);\n          digest = crypto.createHash('sha256').update(message).digest().toString('hex');\n          messageHashUInt8Array = hexToBin(digest);\n          signatureUInt8Array = hexToBin(base64url.toBuffer(encodedSignature).toString('hex'));\n          verified = secp256k1.verifySignatureCompact(signatureUInt8Array, publicKeyUInt8Array, messageHashUInt8Array);\n\n          if (verified) {\n            return [2\n            /*return*/\n            , true];\n          }\n\n          throw new Error('Cannot verify detached signature.');\n      }\n    });\n  });\n};\nexport var sign = function sign(payload, privateKeyJWK, header) {\n  if (header === void 0) {\n    header = {\n      alg: 'ES256K'\n    };\n  }\n\n  return tslib_1.__awaiter(_this, void 0, void 0, function () {\n    var privateKeyUInt8Array, secp256k1, encodedHeader, encodedPayload, toBeSigned, message, digest, messageHashUInt8Array, signatureUInt8Array, signatureHex, encodedSignature;\n    return tslib_1.__generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , privateKeyUInt8ArrayFromJWK(privateKeyJWK)];\n\n        case 1:\n          privateKeyUInt8Array = _a.sent();\n          return [4\n          /*yield*/\n          , instantiateSecp256k1()];\n\n        case 2:\n          secp256k1 = _a.sent();\n          encodedHeader = base64url.encode(JSON.stringify(header));\n          encodedPayload = base64url.encode(JSON.stringify(payload));\n          toBeSigned = encodedHeader + \".\" + encodedPayload;\n          message = Buffer.from(toBeSigned);\n          digest = crypto.createHash('sha256').update(message).digest().toString('hex');\n          messageHashUInt8Array = hexToBin(digest);\n          signatureUInt8Array = secp256k1.signMessageHashCompact(privateKeyUInt8Array, messageHashUInt8Array);\n          signatureHex = binToHex(signatureUInt8Array);\n          encodedSignature = base64url.encode(Buffer.from(signatureHex, 'hex'));\n          return [2\n          /*return*/\n          , encodedHeader + \".\" + encodedPayload + \".\" + encodedSignature];\n      }\n    });\n  });\n};\nexport var verify = function verify(jws, publicKeyJWK) {\n  return tslib_1.__awaiter(_this, void 0, void 0, function () {\n    var secp256k1, publicKeyUInt8Array, _a, encodedHeader, encodedPayload, encodedSignature, toBeSigned, message, digest, messageHashUInt8Array, signatureUInt8Array, verified;\n\n    return tslib_1.__generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , instantiateSecp256k1()];\n\n        case 1:\n          secp256k1 = _b.sent();\n          return [4\n          /*yield*/\n          , publicKeyUInt8ArrayFromJWK(publicKeyJWK)];\n\n        case 2:\n          publicKeyUInt8Array = _b.sent();\n          _a = jws.split('.'), encodedHeader = _a[0], encodedPayload = _a[1], encodedSignature = _a[2];\n          toBeSigned = encodedHeader + \".\" + encodedPayload;\n          message = Buffer.from(toBeSigned);\n          digest = crypto.createHash('sha256').update(message).digest().toString('hex');\n          messageHashUInt8Array = hexToBin(digest);\n          signatureUInt8Array = hexToBin(base64url.toBuffer(encodedSignature).toString('hex'));\n          verified = secp256k1.verifySignatureCompact(signatureUInt8Array, publicKeyUInt8Array, messageHashUInt8Array);\n\n          if (verified) {\n            return [2\n            /*return*/\n            , JSON.parse(base64url.decode(encodedPayload))];\n          }\n\n          throw new JWSVerificationFailed('signature verification failed');\n      }\n    });\n  });\n};\nexport var decode = function decode(jws, options) {\n  if (options === void 0) {\n    options = {\n      complete: false\n    };\n  }\n\n  var _a = jws.split('.'),\n      encodedHeader = _a[0],\n      encodedPayload = _a[1],\n      encodedSignature = _a[2];\n\n  if (options.complete) {\n    return {\n      header: JSON.parse(base64url.decode(encodedHeader)),\n      payload: JSON.parse(base64url.decode(encodedPayload)),\n      signature: encodedSignature\n    };\n  }\n\n  return JSON.parse(base64url.decode(encodedPayload));\n};\nexport default {\n  decode: decode,\n  sign: sign,\n  signDetached: signDetached,\n  verify: verify,\n  verifyDetached: verifyDetached\n};","import React from 'react';\n\nimport * as ES256K from '@transmute/es256k-jws-ts';\n\nimport * as EcsdaSecp256k1Signature2019 from '@transmute/lds-ecdsa-secp256k1-2019';\n\nconst privateJWK = {\n  crv: 'secp256k1',\n  d: 'rhYFsBPF9q3-uZThy7B3c4LDF_8wnozFUAEm5LLC4Zw',\n  kid: 'JUvpllMEYUZ2joO59UNui_XYDqxVqiFLLAJ8klWuPBw',\n  kty: 'EC',\n  x: 'dWCvM4fTdeM0KmloF57zxtBPXTOythHPMm1HCLrdd3A',\n  y: '36uMVGM7hnw-N6GnjFcihWE3SkrhMLzzLCdPMXPEXlA',\n};\n\nconst publicJWK = {\n  crv: 'secp256k1',\n  kid: 'JUvpllMEYUZ2joO59UNui_XYDqxVqiFLLAJ8klWuPBw',\n  kty: 'EC',\n  x: 'dWCvM4fTdeM0KmloF57zxtBPXTOythHPMm1HCLrdd3A',\n  y: '36uMVGM7hnw-N6GnjFcihWE3SkrhMLzzLCdPMXPEXlA',\n};\n\nconst signatureOptions = {\n  challenge: 'abc',\n  created: '2019-01-16T20:13:10Z',\n  domain: 'example.com',\n  proofPurpose: 'authentication',\n  verificationMethod: 'https://example.com/i/alice/keys/2',\n};\nconst doc = {\n  '@context': {\n    action: 'schema:action',\n    schema: 'http://schema.org/',\n  },\n  action: 'AuthenticateMe',\n};\n\nclass App extends React.Component {\n  state = {\n    JWS: '',\n  };\n  async componentWillMount() {\n    const jws = await ES256K.JWS.sign(\n      {\n        hello: 'world',\n      },\n      privateJWK\n    );\n    const verified = await ES256K.JWS.verify(jws, publicJWK);\n    this.setState({\n      jws,\n      verified,\n    });\n\n    const ldSig = await EcsdaSecp256k1Signature2019.sign(\n      doc,\n      signatureOptions,\n      privateJWK\n    );\n\n    const lsSigVerified = await EcsdaSecp256k1Signature2019.verify(\n      ldSig,\n      publicJWK\n    );\n\n    this.setState({\n      ldSig,\n      lsSigVerified,\n    });\n  }\n  render() {\n    return (\n      <div className=\"App\">\n        <h4>ES256K</h4>\n\n        <h5>Public Key</h5>\n        <pre>{JSON.stringify(publicJWK, null, 2)}</pre>\n\n        <h5>JWS</h5>\n        <code>{this.state.jws}</code>\n\n        <h5>Verified Payload</h5>\n        <code>{JSON.stringify(this.state.verified, null, 2)}</code>\n\n        <hr />\n\n        <h5>JSON-LD Signature</h5>\n        <pre>{JSON.stringify(this.state.ldSig, null, 2)}</pre>\n\n        <h5>Verified JSON-LD Signature</h5>\n        <code>{JSON.stringify(this.state.lsSigVerified, null, 2)}</code>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","var _this = this;\n\nimport * as tslib_1 from \"tslib\";\nimport keyto from '@trust/keyto';\nimport base64url from 'base64url';\nimport crypto from 'crypto';\nimport { binToHex, hexToBin, instantiateSecp256k1 } from 'bitcoin-ts';\nimport stringify from 'json-stringify-deterministic';\nvar compressedHexEncodedPublicKeyLength = 66;\n/**\n * Example\n * ```js\n * {\n *  kty: 'EC',\n *  crv: 'secp256k1',\n *  d: 'rhYFsBPF9q3-uZThy7B3c4LDF_8wnozFUAEm5LLC4Zw',\n *  x: 'dWCvM4fTdeM0KmloF57zxtBPXTOythHPMm1HCLrdd3A',\n *  y: '36uMVGM7hnw-N6GnjFcihWE3SkrhMLzzLCdPMXPEXlA',\n *  kid: 'JUvpllMEYUZ2joO59UNui_XYDqxVqiFLLAJ8klWuPBw'\n * }\n * ```\n * See [rfc7638](https://tools.ietf.org/html/rfc7638) for more details on JWK.\n */\n\nexport var getKid = function getKid(jwk) {\n  var copy = tslib_1.__assign({}, jwk);\n\n  delete copy.d;\n  delete copy.kid;\n  delete copy.alg;\n  var digest = crypto.createHash('sha256').update(stringify(copy)).digest();\n  return base64url.encode(Buffer.from(digest));\n};\n/** convert compressed hex encoded private key to jwk */\n\nexport var privateJWKFromPrivateKeyHex = function privateJWKFromPrivateKeyHex(privateKeyHex) {\n  return tslib_1.__awaiter(_this, void 0, void 0, function () {\n    var jwk, kid;\n    return tslib_1.__generator(this, function (_a) {\n      jwk = tslib_1.__assign({}, keyto.from(privateKeyHex, 'blk').toJwk('private'), {\n        crv: 'secp256k1'\n      });\n      kid = getKid(jwk);\n      return [2\n      /*return*/\n      , tslib_1.__assign({}, jwk, {\n        kid: kid\n      })];\n    });\n  });\n};\n/** convert compressed hex encoded public key to jwk */\n\nexport var publicJWKFromPublicKeyHex = function publicJWKFromPublicKeyHex(publicKeyHex) {\n  return tslib_1.__awaiter(_this, void 0, void 0, function () {\n    var secp256k1, key, jwk, kid;\n    return tslib_1.__generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , instantiateSecp256k1()];\n\n        case 1:\n          secp256k1 = _a.sent();\n          key = publicKeyHex;\n\n          if (publicKeyHex.length === compressedHexEncodedPublicKeyLength) {\n            key = binToHex(secp256k1.uncompressPublicKey(hexToBin(publicKeyHex)));\n          }\n\n          jwk = tslib_1.__assign({}, keyto.from(key, 'blk').toJwk('public'), {\n            crv: 'secp256k1'\n          });\n          kid = getKid(jwk);\n          return [2\n          /*return*/\n          , tslib_1.__assign({}, jwk, {\n            kid: kid\n          })];\n      }\n    });\n  });\n};\n/** convert pem encoded private key to jwk */\n\nexport var privateJWKFromPrivateKeyPem = function privateJWKFromPrivateKeyPem(privateKeyPem) {\n  var jwk = tslib_1.__assign({}, keyto.from(privateKeyPem, 'pem').toJwk('private'), {\n    crv: 'secp256k1'\n  }); // console.log(jwk);\n\n\n  var kid = getKid(jwk);\n  return tslib_1.__assign({}, jwk, {\n    kid: kid\n  });\n};\n/** convert pem encoded private key to jwk */\n\nexport var publicJWKFromPublicKeyPem = function publicJWKFromPublicKeyPem(publicKeyPem) {\n  var jwk = tslib_1.__assign({}, keyto.from(publicKeyPem, 'pem').toJwk('public'), {\n    crv: 'secp256k1'\n  });\n\n  var kid = getKid(jwk);\n  return tslib_1.__assign({}, jwk, {\n    kid: kid\n  });\n};\n/** convert jwk to hex encoded private key */\n\nexport var privateKeyHexFromJWK = function privateKeyHexFromJWK(jwk) {\n  return tslib_1.__awaiter(_this, void 0, void 0, function () {\n    return tslib_1.__generator(this, function (_a) {\n      return [2\n      /*return*/\n      , keyto.from(tslib_1.__assign({}, jwk, {\n        crv: 'K-256'\n      }), 'jwk').toString('blk', 'private')];\n    });\n  });\n};\n/** convert jwk to hex encoded public key */\n\nexport var publicKeyHexFromJWK = function publicKeyHexFromJWK(jwk) {\n  return tslib_1.__awaiter(_this, void 0, void 0, function () {\n    var secp256k1, uncompressedPublicKey, compressed;\n    return tslib_1.__generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , instantiateSecp256k1()];\n\n        case 1:\n          secp256k1 = _a.sent();\n          uncompressedPublicKey = keyto.from(tslib_1.__assign({}, jwk, {\n            crv: 'K-256'\n          }), 'jwk').toString('blk', 'public');\n          compressed = secp256k1.compressPublicKey(hexToBin(uncompressedPublicKey));\n          return [2\n          /*return*/\n          , binToHex(compressed)];\n      }\n    });\n  });\n};\n/** convert jwk to binary encoded private key */\n\nexport var privateKeyUInt8ArrayFromJWK = function privateKeyUInt8ArrayFromJWK(jwk) {\n  return tslib_1.__awaiter(_this, void 0, void 0, function () {\n    var privateKeyHex;\n    return tslib_1.__generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , privateKeyHexFromJWK(jwk)];\n\n        case 1:\n          privateKeyHex = _a.sent();\n          return [2\n          /*return*/\n          , hexToBin(privateKeyHex)];\n      }\n    });\n  });\n};\n/** convert jwk to binary encoded public key */\n\nexport var publicKeyUInt8ArrayFromJWK = function publicKeyUInt8ArrayFromJWK(jwk) {\n  return tslib_1.__awaiter(_this, void 0, void 0, function () {\n    var publicKeyHex;\n    return tslib_1.__generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , publicKeyHexFromJWK(jwk)];\n\n        case 1:\n          publicKeyHex = _a.sent();\n          return [2\n          /*return*/\n          , hexToBin(publicKeyHex)];\n      }\n    });\n  });\n};\nexport default {\n  binToHex: binToHex,\n  getKid: getKid,\n  hexToBin: hexToBin,\n  privateJWKFromPrivateKeyHex: privateJWKFromPrivateKeyHex,\n  privateJWKFromPrivateKeyPem: privateJWKFromPrivateKeyPem,\n  privateKeyHexFromJWK: privateKeyHexFromJWK,\n  privateKeyUInt8ArrayFromJWK: privateKeyUInt8ArrayFromJWK,\n  publicJWKFromPublicKeyHex: publicJWKFromPublicKeyHex,\n  publicJWKFromPublicKeyPem: publicJWKFromPublicKeyPem,\n  publicKeyHexFromJWK: publicKeyHexFromJWK,\n  publicKeyUInt8ArrayFromJWK: publicKeyUInt8ArrayFromJWK\n};","var _this = this;\n\nimport * as tslib_1 from \"tslib\";\nimport createVerifyData from './createVerifyData';\nimport { JWS } from '@transmute/es256k-jws-ts';\nexport var sign = function sign(payload, signatureOptions, privateKeyJwk) {\n  return tslib_1.__awaiter(_this, void 0, void 0, function () {\n    var _a, framed, verifyDataHexString, verifyDataBuffer, jws, documentWithProof;\n\n    return tslib_1.__generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , createVerifyData(payload, signatureOptions)];\n\n        case 1:\n          _a = _b.sent(), framed = _a.framed, verifyDataHexString = _a.verifyDataHexString;\n          verifyDataBuffer = Buffer.from(verifyDataHexString, 'hex');\n          return [4\n          /*yield*/\n          , JWS.signDetached(verifyDataBuffer, privateKeyJwk)];\n\n        case 2:\n          jws = _b.sent();\n          documentWithProof = tslib_1.__assign({}, framed, {\n            proof: tslib_1.__assign({}, signatureOptions, {\n              jws: jws\n            })\n          });\n          return [2\n          /*return*/\n          , documentWithProof];\n      }\n    });\n  });\n};\nexport var verify = function verify(payload, publicKeyJwk) {\n  return tslib_1.__awaiter(_this, void 0, void 0, function () {\n    var _a, framed, verifyDataHexString, verifyDataBuffer;\n\n    return tslib_1.__generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , createVerifyData(payload, payload.proof)];\n\n        case 1:\n          _a = _b.sent(), framed = _a.framed, verifyDataHexString = _a.verifyDataHexString;\n          verifyDataBuffer = Buffer.from(verifyDataHexString, 'hex');\n          return [2\n          /*return*/\n          , JWS.verifyDetached(payload.proof.jws, verifyDataBuffer, publicKeyJwk)];\n      }\n    });\n  });\n};","var _this = this;\n\nimport * as tslib_1 from \"tslib\";\nimport crypto from 'crypto';\nimport jsonld from 'jsonld';\n\nvar canonize = function canonize(data) {\n  return tslib_1.__awaiter(_this, void 0, void 0, function () {\n    return tslib_1.__generator(this, function (_a) {\n      return [2\n      /*return*/\n      , jsonld.canonize(data)];\n    });\n  });\n};\n\nvar sha256 = function sha256(data) {\n  var h = crypto.createHash('sha256');\n  h.update(data);\n  return h.digest('hex');\n};\n\nvar cannonizeSignatureOptions = function cannonizeSignatureOptions(signatureOptions) {\n  var _signatureOptions = tslib_1.__assign({}, signatureOptions, {\n    '@context': 'https://w3id.org/security/v2'\n  });\n\n  delete _signatureOptions.jws;\n  delete _signatureOptions.signatureValue;\n  delete _signatureOptions.proofValue;\n  return canonize(_signatureOptions);\n};\n\nvar cannonizeDocument = function cannonizeDocument(doc) {\n  var _doc = tslib_1.__assign({}, doc);\n\n  delete _doc.proof;\n  return canonize(_doc);\n};\n\nvar createVerifyData = function createVerifyData(data, signatureOptions) {\n  return tslib_1.__awaiter(_this, void 0, void 0, function () {\n    var expanded, framed, cannonizedSignatureOptions, hashOfCannonizedSignatureOptions, cannonizedDocument, hashOfCannonizedDocument;\n    return tslib_1.__generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          if (signatureOptions.creator) {\n            signatureOptions.verificationMethod = signatureOptions.creator;\n          }\n\n          if (!signatureOptions.verificationMethod) {\n            throw new Error('signatureOptions.verificationMethod is required');\n          }\n\n          if (!signatureOptions.created) {\n            signatureOptions.created = new Date().toISOString();\n          }\n\n          signatureOptions.type = 'EcdsaSecp256k1Signature2019';\n          return [4\n          /*yield*/\n          , jsonld.expand(data)];\n\n        case 1:\n          expanded = _a.sent()[0];\n          return [4\n          /*yield*/\n          , jsonld.compact(expanded, 'https://w3id.org/security/v2', {\n            skipExpansion: true\n          })];\n\n        case 2:\n          framed = _a.sent();\n          return [4\n          /*yield*/\n          , cannonizeSignatureOptions(signatureOptions)];\n\n        case 3:\n          cannonizedSignatureOptions = _a.sent();\n          hashOfCannonizedSignatureOptions = sha256(cannonizedSignatureOptions);\n          return [4\n          /*yield*/\n          , cannonizeDocument(framed)];\n\n        case 4:\n          cannonizedDocument = _a.sent();\n          hashOfCannonizedDocument = sha256(cannonizedDocument);\n          return [2\n          /*return*/\n          , {\n            framed: framed,\n            verifyDataHexString: hashOfCannonizedSignatureOptions + hashOfCannonizedDocument\n          }];\n      }\n    });\n  });\n};\n\nexport default createVerifyData;"],"sourceRoot":""}